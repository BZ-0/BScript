// @ts-nocheck
"use strict";

//
import AutoDetector from "../Reflection/AutoDetector";
import MessageCoderWorker from "./MessageCoderWorker";
import SyncPromise, { $getter } from "../Library/SyncPromise"

//
import { wrapFunc, AccessReflection } from "../Reflection/DirectReflection";
import { _LOG_ } from "../Library/Symbols";

// for protocol
export default class MessageCoderAtomic extends MessageCoderWorker {
    $isAtomic = true;
    $proxify = null;
    $encodingRules = null;
    $decodingRules = null;

    //
    constructor($sup) {
        super($sup);

        //
        this.$isAtomic = true;

        //
        const $proxify = ([$code], {$untyped}) => {
            return this.$dictionary.$temp($getter($untyped), {
                ["&origin"]: $code?.["&proxy"], 
                ["&root"]: ($code?.["&root"] ?? $code?.["&origin"]),
                ["&persistent"]: $code?.["&persistent"]
            }, $untyped)?.["&code"];
        };

        //
        this.$encodingRules = new Map([
            //
            ["array", ([_, $shared], {$untyped}) => { return $untyped.map((e) => this.encodeMember(e, $shared)); }],
            ["worker", $proxify],
            ["socket", $proxify],
            ["class", $proxify],
            ["proxy", $proxify],

            // i.e. transfer policy (except shared)
            ["shared", ([_, $shared], {$wrap}) => {
                const $data = $wrap?.["&data"];
                const $index = $data ? ($shared?.length ?? -1) : -1;
                if ($data) $shared?.push?.(
                    ($data?.buffer && $data.BYTES_PER_ELEMENT || $data instanceof DataView) && !($data instanceof WebAssembly.Memory) ? 
                    ($data?.buffer || $data) : $data);
                return {
                    ["&typeof"]: "shared", 
                    ["&byteOffset"]: $data?.byteOffset || 0, 
                    ["&byteLength"]: $data?.byteLength || 0, 
                    ["&index"]: $index, 
                    ["&type"]: this.$detector.$typedarray($data)
                };
            }],

            //
            ["transfer", ([_, $shared], {$wrap, $receiver}) => {
                return this.$dictionary.$temp(async do {
                    const $data = await $wrap?.["&data"];
                    const $index = $data ? ($shared?.length ?? -1) : -1;
                    const $raw = ($data?.buffer && $data.BYTES_PER_ELEMENT || $data instanceof DataView) && !($data instanceof WebAssembly.Memory) ? ($data?.buffer || $data) : $data;

                    // set an ReadbackReflection proxy object around identifier
                    if ($receiver && this.$detector.$dropShared($raw)) {
                        $wrap["&data"] = $receiver?.$transfer?.([$raw], $shared);
                    } else {
                        // just add to transfer list
                        if ($raw) $shared?.push?.($raw);
                    }

                    // 
                    return {
                        ["&isCode"]: true,
                        ["&meta"]: $wrap?.["&meta"], 
                        ["&typeof"]: "transfer", 
                        ["&byteOffset"]: ( $data.byteOffset) || 0, 
                        ["&byteLength"]: ( $data.byteLength) || 0, 
                        ["&index"]: (await $wrap?.["&data"]?.["&index"]) ?? $index, 
                        ["&local"]: (await $wrap?.["&data"]?.["&local"]), // will be used for feedback resolve
                        ["&type"]: this.$detector.$typedarray($data)
                    };
                }, {
                    ["&typeof"]: "access",
                    ["&origin"]: $code?.["&proxy"], 
                    ["&root"]: ($code?.["&root"] ?? $code?.["&origin"]),
                    ["&persistent"]: $code?.["&persistent"]
                })?.["&code"];
            }]

            //
            ["promise", ([$code, $shared], {$untyped}) => {
                return this.$dictionary.$temp($getter($untyped), {
                    ["&typeof"]: "access",
                    ["&origin"]: $code?.["&proxy"], 
                    ["&root"]: ($code?.["&root"] ?? $code?.["&origin"]),
                    ["&persistent"]: $code?.["&persistent"]
                }, $untyped)?.["&code"];
            }],

            // i.e. copy policy
            ["typedarray", ([_], {$wrap}) => {
                return ( $wrap?.["&data"]);
            }],

            //
            ["object", ([_, $shared], {$untyped}) => {
                return Object.fromEntries(Object.entries($untyped).map( (pair) => { return [pair[0], this.encodeMember(pair[1], $shared)]; }));
            }],
        ]);

        //
        this.$decodingRules = new Map([
            ["transfer", ([coded, shared], {$sender}) => {
                const $buffer = shared?.[coded["&index"]];
                const $instance = this.$detector.$typewrap(coded["&type"], $buffer?.buffer || $buffer, coded["&byteOffset"] + ($buffer?.byteOffset||0), coded["&byteLength"]||0, coded?.["&meta"]);

                // send identifier of transferred object
                $sender?.$feedback?.(coded, $instance); // will be stored in $temp directionary for access
                return $instance;
            }],

            ["shared", ([coded, shared]) => {
                const $buffer = shared?.[coded["&index"]];
                if (!coded["&type"] || coded["&type"] == "$unk") return $buffer;
                return this.$detector.$typewrap(coded["&type"], $buffer?.buffer || $buffer, coded["&byteOffset"] + ($buffer?.byteOffset||0), coded["&byteLength"]||0);
            }],

            //
            ["class", ([_]) => { throw Error("Currently, class can't to be a decodable!"); }],

            //
            ["access", async ([coded, shared]) => {
                // when async mode, access should to be also decoded
                return new Proxy(wrapFunc({
                    ["&code"]: { ["&typeof"]: "promise" },
                    ["&data"]: new Proxy(coded, new AccessReflection(Reflect, this.$handler)).then(($)=>{
                        return this.decodeMember($, shared);
                    })
                }), this.$handler.$promiseReflection);
            }],

            //
            ["proxy", ([coded]) => {
                //console.log(coded?.["&origin"], coded?.["&proxy"]);
                // ask as by proxy, also by origin
                // (note: you must mean, that `origin` means original obj directly, while `proxy` may be a chain of proxy)
                const hasOrigin = 
                    this.$dictionary.$get(coded?.["&root"], coded?.["&persistent"]) ?? 
                    this.$dictionary.$get(coded?.["&origin"], coded?.["&persistent"]) ?? 
                    this.$dictionary.$get(coded?.["&proxy"], coded?.["&persistent"]);
                if (hasOrigin) return hasOrigin;

                //
                return new Proxy(wrapFunc({
                    ["&data"]: null,
                    ["&code"]: coded
                }), this.$requestReflect);
            }],
            ["array", ([coded, shared]) => {
                return (coded["&data"] ?? coded).map((m) => this.decodeMember(m, shared));
            }],
            ["object", ([coded, shared]) => {
                const _entries_ = Object.entries(coded["&data"] ?? coded);
                return Object.fromEntries(_entries_.map((pair) => { return [pair[0], this.decodeMember(pair[1], shared)]; }));
            }],
            ["typedarray", ([coded]) => {
                return coded?.["&data"] ?? coded;
            }]
        ]);

        // TODO? Planned to use when working and return to client stage...
        this.$transcodingRules = new Map([]);
    }

    // almost full support planned on v2.3
    waitResponseSync($buffer = null, $timeout = 1000) {
        const btime = performance.now();
        const u32a = new Uint32Array($buffer, 0, 1);
        while (Atomics.load(u32a, 0) <= 0) {
            if ((performance.now() - btime) >= $timeout) break;
        }
        return this.decodeMessage([new Uint8Array($buffer, 8, Atomics.load(u32a, 0)), $buffer], []);
    }

    //
    decodeMessage([$message, $buffer = null], $shared = []) {
        const _unwrap_ = (this.$decode || ((e) => { return (this.$msgpck)?.decode(e, {useBigInt64: true}); }))?.($message);
        _unwrap_.$args = (_unwrap_.$args?.map?.((m) => this.decodeMember(m, $shared)) ?? []);
        //console.log(_unwrap_.$args);
        return [[_unwrap_, $buffer], $shared.concat([$buffer])];
    }

    //
    encodeMessage([$data, $buffer = null, $receive = false], $shared = []) {
        $buffer ??= typeof SharedArrayBuffer != "undefined" ? new SharedArrayBuffer(4096+8, {
            maxByteLength: 65536+8
        }) : new ArrayBuffer(4096+8, {
            maxByteLength: 65536+8
        });

        $data.$worker = (typeof $data.$worker == "string" ? $data.$worker : undefined); // unsupported...
        $data.$args = (($data.$args?.map?.((e) => this.encodeMember(e, $shared)) ?? []));
        const _wrap_ = (this.$encode || ((e) => { return (this.$msgpck)?.encode(e, {useBigInt64: true}); }))?.($data);

        //
        if ($receive) { // when received by remote, need to copy buffer
            if (($buffer.byteLength-8) < _wrap_.byteLength) $buffer.grow(_wrap_.byteLength+8);
            const _copy_ = new Uint8Array($buffer, 8, _wrap_.byteLength); _copy_.set(_wrap_);
            const _len_ = new Uint32Array($buffer, 0, 1);
            if (typeof Atomics != "undefined") {
                Atomics.store(_len_, 0, _wrap_.byteLength);
            } else {
                _len_[0] = _wrap_.byteLength;
            }
            return [[_copy_, $buffer], $shared.concat([_copy_.buffer, $buffer])];
        } else {
            const _copy_ = new Uint8Array(_wrap_);
            return [[_copy_, $buffer], $shared.concat([_copy_.buffer, $buffer])];
        }
    }

    // TODO! Needs client-side error handling...
    decodeError(..._) {
        throw Error("Unhandled internal error...");
    }

    // TODO! Needs client-side error handling...
    encodeError([$data, $buffer], $shared = []) {
        delete $data?.$args;
        delete $data?.["&data"];
        const _wrap_ = (this.$encode || ((e) => { return (this.$msgpck)?.encode(e, {useBigInt64: true}); }))?.($data);
        return [[_wrap_, $buffer], $shared.concat([_wrap_.buffer, $buffer])];
    }

    //
    decodeMember(coded, shared = []) {
        // if is null, prefer don't decode...
        if (!coded || ["object", "function"].indexOf(typeof coded) < 0) return coded;
        if (!coded?.["&typeof"]) coded = new AutoDetector(coded)["&code"];
        return (this.$decodingRules.get(coded?.["&typeof"])?.([coded, shared]) ?? (coded?.["&data"]) ?? coded);
    }

    // 
    encodeMember($wrap, $shared = []) {
        if (["object", "function"].indexOf(typeof $wrap) < 0) return $wrap; 

        //
        const $untyped = $wrap;
        let $typeof = $wrap?.["&typeof"];
        if (!$typeof) {
            $wrap = new AutoDetector($wrap);
            $typeof = $wrap?.["&typeof"];
        }

        //
        return this.$encodingRules.get($typeof)?.([$wrap["&code"], $shared], {$wrap, $untyped}) ?? $wrap?.["&data"];
    }
};
