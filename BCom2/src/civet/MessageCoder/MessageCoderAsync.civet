// @ts-nocheck
"use strict";

//
import { msgpackM } from "../Library/Imports";
import AutoDetector from "../Reflection/AutoDetector";
import { _LOG_ } from "../Library/Symbols";
import { $unwrap } from "../Reflection/PromiseReflection";
import { wrapFunc, AccessReflection } from "../Reflection/DirectReflection";
import SyncPromise, { $getter } from "../Library/SyncPromise"

// for protocol
export default class MessageCoderAsync {
    /** @type {AutoDetector} */
    $detector = null;

    /** @type {ReferenceDictionary} */
    $dictionary = null;

    /** @type {MessageHandler} */
    $messageHandler = null;

    /** @type {RequestReflection} */
    $requestReflect = null;

    /** @type {IndirectReflection} */
    $indirectReflect = null;

    /** @type {PromiseReflection} */
    $promiseReflect = null;

    //
    $encodingRules = new Map([]);
    $decodingRules = new Map([]);
    $transcodingRules = new Map([]);

    //
    $encode = null;
    $decode = null;
    $msgpck = null;

    //
    $proxify = null;
    $handler = null;

    //
    constructor({$detector, $dictionary, $requestReflect, $indirectReflect, $promiseReflect, $encode, $decode, $handler}) {
        this.$dictionary = $dictionary;
        this.$detector = $detector;
        this.$requestReflect = $requestReflect;
        this.$indirectReflect = $indirectReflect;
        this.$promiseReflect = $promiseReflect;
        this.$encode = $encode;
        this.$decode = $decode;
        this.$msgpck = msgpackM;
        this.$handler = $handler;

        //
        const $proxify = async ([$code, $shared], {$untyped}) => {
            return this.$dictionary.$temp($getter($untyped), {
                ["&origin"]: $code?.["&proxy"], 
                ["&root"]: ($code?.["&root"] ?? $code?.["&origin"]),
                ["&persistent"]: $code?.["&persistent"]
            }, $untyped)?.["&code"];
        };

        //
        this.$encodingRules = new Map([
            //
            ["array", ([_, $shared], {$untyped}) => { return Promise.all($untyped.map((e) => this.encodeMember(e, $shared))); }],
            ["worker", $proxify],
            ["socket", $proxify],
            ["class", $proxify],
            ["proxy", $proxify],
            ["transfer", $proxify],
            ["shared", $proxify],

            //
            ["promise", ([$code, $shared], {$untyped}) => {
                return this.$dictionary.$temp($getter($untyped), {
                    ["&typeof"]: "access",
                    ["&origin"]: $code?.["&proxy"], 
                    ["&root"]: ($code?.["&root"] ?? $code?.["&origin"]),
                    ["&persistent"]: $code?.["&persistent"]
                }, $untyped)?.["&code"];
            }],

            // i.e. copy policy
            ["typedarray", ([_], {$wrap}) => {
                return ( $wrap?.["&data"]);
            }],

            //
            ["object", ([_, $shared], {$untyped}) => {
                return Promise.all(Object.entries($untyped).map( (pair) => { return [pair[0], this.encodeMember(pair[1], $shared)]; })).then(($)=>{
                    return Object.fromEntries($);
                });
            }],
        ]);

        //
        this.$decodingRules = new Map([
            ["class", ([_]) => {
                throw Error("Currently, class can't to be a decodable!");
            }],

            //
            ["access", async ([coded, shared]) => {
                // when async mode, access should to be also decoded
                return this.decodeMember(await new Proxy(coded, new AccessReflection(Reflect, this.$handler)), shared);
            }],

            //
            ["proxy", ([coded]) => {
                const hasOrigin = 
                    this.$dictionary.$get(coded?.["&root"], coded?.["&persistent"]) ?? 
                    this.$dictionary.$get(coded?.["&origin"], coded?.["&persistent"]) ?? 
                    this.$dictionary.$get(coded?.["&proxy"], coded?.["&persistent"]);

                //
                if (hasOrigin) { 
                    return hasOrigin; 
                };

                //
                return new Proxy(wrapFunc({
                    ["&data"]: null,
                    ["&code"]: coded
                }), this.$requestReflect);
            }],
            ["array", ([coded, shared]) => {
                return Promise.all((coded["&data"] ?? coded).map((m) => this.decodeMember(m, shared)));
            }],
            ["object", ([coded, shared]) => {
                return Promise.all(Object.entries(coded["&data"] ?? coded).map((pair) => { return [pair[0], this.decodeMember(pair[1], shared)]; })).then(($)=>{
                    return Object.fromEntries($);
                });
            }],
            ["typedarray", ([coded]) => {
                return coded?.["&data"] ?? coded;
            }],
            
        ]);

        // 
        this.$transcodingRules = new Map([]);
    }

    //
    async decodeMessage([$message, $buffer = null], $shared = []) {
        const _unwrap_ = await (this.$decode || (async (e) => { 
            return (await this.$msgpck)?.decode(e, {useBigInt64: true}); 
        }))?.(await $message);
        _unwrap_.$args = await Promise.all(_unwrap_.$args?.map?.((m) => this.decodeMember(m, $shared)) ?? []);
        return [[_unwrap_, $buffer], $shared.concat([$buffer])];
    }

    // TODO! Needs client-side error handling...
    decodeError(..._) {
        throw Error("Unhandled internal error...");
    }

    // 
    async encodeError([$data, $buffer], $shared = []) {
        delete $data?.$args;
        delete $data?.["&data"];
        const _wrap_ = await (this.$encode || ( async (e) => { return (await this.$msgpck)?.encode(e, {useBigInt64: true}); }))?.($data);
        return [[_wrap_, $buffer], $shared.concat([_wrap_.buffer, $buffer])];
    }

    //
    async decodeMember(coded, shared = []) {
        // if is null, prefer don't decode...
        coded = await coded;
        if (!coded || ["object", "function"].indexOf(typeof coded) < 0) return coded;
        if (!coded?.["&typeof"]) coded = new AutoDetector(coded)["&code"];

        //
        const $sender = this?.$getDataChannel?.(coded?.["&meta"]);
        const $recode = await (this.$decodingRules.get(coded?.["&typeof"])?.([coded, shared], {$sender}) ?? (coded?.["&data"]) ?? coded);
        $sender?.$finalizer?.($recode);
        return $recode;
    }

    //
    async encodeMessage([$data, $buffer = null, $receive = false], $shared = []) {
        //$data.$worker = await $data.$worker;
        $data.$args = await Promise.all($data.$args?.map?.((e) => this.encodeMember(e, $shared)) ?? []);
        const _wrap_ = (this.$encode || this.$msgpck?.encode)($data, {useBigInt64: true});

        //
        if ($receive) { // when received by remote, need to copy buffer
            if (($buffer.byteLength-8) < _wrap_.byteLength) $buffer.grow(_wrap_.byteLength+8);
            const _copy_ = new Uint8Array($buffer, 8, _wrap_.byteLength); _copy_.set(_wrap_);
            const _len_ = new Uint32Array($buffer, 0, 1);
            if (typeof Atomics != "undefined") {
                Atomics.store(_len_, 0, _wrap_.byteLength);
            } else {
                _len_[0] = _wrap_.byteLength;
            }
            return [[_copy_, $buffer], $shared.concat([_copy_.buffer, $buffer])];
        } else {
            const _copy_ = new Uint8Array(_wrap_);
            return [[_copy_, $buffer], $shared.concat([_copy_.buffer, $buffer])];
        }
    }

    // 
    async encodeMember($wrap, $shared = []) {
        if (["transfer", "promise", "proxy"].indexOf($wrap?.["&typeof"]) < 0) {
            $wrap = await $unwrap(await $wrap);
        }
        if (!$wrap || ["object", "function"].indexOf(typeof $wrap) < 0) return $wrap;

        //
        const $untyped = $wrap;
        let $typeof = $wrap?.["&typeof"];
        if (!$typeof) {
            $wrap = new AutoDetector($wrap);
            $typeof = $wrap?.["&typeof"];
        }

        // 
        const $code = $wrap["&code"];
        const $receiver = await this?.$getDataChannel?.($untyped?.["&meta"]); $receiver?.$finalizer?.($untyped);
        return (this.$encodingRules.get($typeof)?.([$code, $shared], {$wrap, $receiver, $untyped}) ?? ($wrap?.["&data"]));
    }
};
