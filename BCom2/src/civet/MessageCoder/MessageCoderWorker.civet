// @ts-nocheck
"use strict";

//
import { _LOG_ } from "../Library/Symbols";
import MessageCoderAsync from "./MessageCoderAsync";

// for protocol
export default class MessageCoderWorker extends MessageCoderAsync {
    constructor($sup) {
        super($sup);

        //
        this.$decodingRules.set("shared", ([coded, shared]) => {
            const $buffer = shared?.[coded["&index"]];
            if (!coded["&type"] || coded["&type"] == "$unk") return $buffer;
            return this.$detector.$typewrap(coded["&type"], $buffer?.buffer || $buffer, coded["&byteOffset"] + ($buffer?.byteOffset||0), coded["&byteLength"]||0);
        });

        //
        this.$decodingRules.set("transfer", ([coded, shared], {$sender}) => {
            const $buffer = shared?.[coded["&index"]];
            const $instance = this.$detector.$typewrap(coded["&type"], $buffer?.buffer || $buffer, coded["&byteOffset"] + ($buffer?.byteOffset||0), coded["&byteLength"]||0, coded?.["&meta"]);

            // send identifier of transferred object
            $sender?.$feedback?.(coded, $instance); // will be stored in $temp directionary for access
            return $instance;
        });

        // i.e. transfer policy (except shared)
        this.$encodingRules.set("shared", async ([_, $shared], {$wrap}) => {
            const $data = await $wrap?.["&data"];
            const $index = $data ? ($shared?.length ?? -1) : -1;
            if ($data) $shared?.push?.(
                ($data?.buffer && $data.BYTES_PER_ELEMENT || $data instanceof DataView) && !($data instanceof WebAssembly.Memory) ? 
                ($data?.buffer || $data) : $data);
            return {
                ["&typeof"]: "shared", 
                ["&byteOffset"]: $data?.byteOffset || 0, 
                ["&byteLength"]: $data?.byteLength || 0, 
                ["&index"]: $index, 
                ["&type"]: this.$detector.$typedarray($data)
            };
        });

        //
        this.$encodingRules.set("transfer", async ([_, $shared], {$wrap, $receiver}) => {
            const $data = await $wrap?.["&data"];
            const $index = $data ? ($shared?.length ?? -1) : -1;
            const $raw = ($data?.buffer && $data.BYTES_PER_ELEMENT || $data instanceof DataView) && !($data instanceof WebAssembly.Memory) ? ($data?.buffer || $data) : $data;

            // set an ReadbackReflection proxy object around identifier
            if ($receiver && this.$detector.$dropShared($raw)) {
                $wrap["&data"] = $receiver?.$transfer?.([$raw], $shared);
            } else {
                // just add to transfer list
                if ($raw) $shared?.push?.($raw);
            }

            // 
            return {
                ["&isCode"]: true,
                ["&meta"]: await $wrap?.["&meta"], 
                ["&typeof"]: "transfer", 
                ["&byteOffset"]: ( $data.byteOffset) || 0, 
                ["&byteLength"]: ( $data.byteLength) || 0, 
                ["&index"]: (await $wrap?.["&data"]?.["&index"]) ?? $index, 
                ["&local"]: (await $wrap?.["&data"]?.["&local"]), // will be used for feedback resolve
                ["&type"]: this.$detector.$typedarray($data)
            };
        });

    }

    //
    async $getDataChannel($meta, $holder) {
        if (!(await $meta)) return null;
        return this.$messageHandler.$initiate(await $meta, $holder);
    }
}
