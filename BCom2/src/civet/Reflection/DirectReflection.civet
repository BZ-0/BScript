// @ts-nocheck
"use strict";

//
import { $symbols, $names, $contextify, FakeReflect } from "../Library/Symbols";

//
export class BaseReflection {
    /** @type {Reflect} */
    $reflect = (typeof Reflect != "undefined" ? Reflect : FakeReflect);

    //
    constructor(reflect) {
        this.$reflect = reflect ?? (typeof Reflect != "undefined" ? Reflect : FakeReflect);
    }

    //
    $data($hack) {
        return $hack?.["&data"];
    }

    //
    get($hack, ...$args) {
        if ($args[0] == "&isCode") 
            return false;
        if ($args[0] == "&isWrap")
            return true;
        if (["&data", "&code"].indexOf($args[0]) >= 0) 
            return $hack?.[$args[0]];
        if ([$symbols["&data"]].indexOf($args[0]) >= 0) 
            return this.$data($hack);
        if ($args[0]?.at?.(0) == "&") 
            return $hack?.["&code"]?.[$args[0]];

        //
        if (Object.values($symbols).indexOf($args[0]) >= 0) { 
            $args[0] = $names[$args[0]];
            const $w = this.$data($hack)?.["&code"] ?? $hack?.["&code"];
            return $contextify($w, this.$reflect.get($w, ...$args));
        }

        //
        if (["then", "catch", "finally"].indexOf($args[0]) >= 0) {
            const $w = this.$data($hack);
            if ($w?.[$args[0]]) {
                return $contextify($w, $w?.[$args[0]]);
            } else {
                const $p = new Promise(($) => $( $w ));
                return $contextify($p, $p?.[$args[0]]);
            }
            //return null;
        }

        //
        const $data = this.$data($hack);
        return $contextify($data, this.$reflect.get($data, ...$args));
    }

    set($hack, ...$args) {
        if ($args[0] == "&data") { 
            $hack["&data"] = $args[1]; 
            return true;
        };
        return this.$reflect.set(this.$data($hack), ...$args);
    }

    deleteProperty($hack, ...$args) {
        return this.$reflect.deleteProperty(this.$data($hack), ...$args);
    }

    construct($hack, ...$args) {
        return this.$reflect.construct(this.$data($hack), ...$args);
    }

    apply($hack, ...$args) {
        return this.$reflect.apply(this.$data($hack), ...$args);
    }

    ownKeys($hack, ...$args) {
        return this.$reflect.ownKeys(this.$data($hack), ...$args);
    }

    has($hack, ...$args) {
        return this.$reflect.has(this.$data($hack), ...$args);
    }
};


//
export class DirectReflection extends BaseReflection {

    //
    constructor($reflect = (typeof Reflect != "undefined" ? Reflect : FakeReflect)) {
        super($reflect);
    }

    //
    $data($hack) {
        return $hack?.["&data"];
    }
};

//
export class GetterReflection extends BaseReflection {

    //
    constructor($reflect = (typeof Reflect != "undefined" ? Reflect : FakeReflect)) {
        super($reflect);
    }

    //
    $data($hack) {
        return ($hack?.["&data"] ?? $hack)();
    }
};

// from remote side...
export class IndirectReflection extends BaseReflection {
    #dictionary = null;

    //
    constructor(reflect = (typeof Reflect != "undefined" ? Reflect : FakeReflect), dictionary = null) {
        super(reflect);
        this.#dictionary = dictionary;
    }

    //
    $data($hack) {
        const $wrap = 
            this.#dictionary.$get($hack?.["&origin"], $hack?.["&persistent"]) ??
            this.#dictionary.$get($hack?.["&proxy"], $hack?.["&persistent"]) ??
            $hack?.["&data"]
        return $wrap;
    }
};

// from remote side...
export class AccessReflection extends BaseReflection {
    #dictionary = null;
    #worker = null;

    //
    constructor(reflect = (typeof Reflect != "undefined" ? Reflect : FakeReflect), worker = null) {
        super(reflect);
        this.#worker = worker;
    }

    //
    $data($hack) {
        return ($hack["&data"] = ($hack["&data"] ?? this.#worker.access($hack["&proxy"], $hack["&persistent"])));
    }
};

// from remote side...
export class ReadbackReflection extends BaseReflection {
    #worker = null;

    //
    constructor(worker) {
        super(Reflect);
        this.#worker = worker;
    }

    //
    $data($hack) {
        if ($hack?.["&typeof"] == "readback") {
            $hack["&typeof"] = "data";
            $hack["&data"] = this.#worker.$request({$cmd: "access", $identify: true, $persistent: false, $args: [$hack["&data"].then(($) => { 
                return $["&origin"];
            })]});
        }
        return $hack["&data"];
    }

};

//
export const defaultReflection = new DirectReflection();
export const wrapFunc = ($ = {}) => {
    const $Direct = function $Direct() {
        Object.assign(this, $);
    };
    Object.assign($Direct, $);
    return $Direct;//new Proxy(, defaultReflection);
}
