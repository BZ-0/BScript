// @ts-nocheck
"use strict";

//
import { _LOG_ } from "../Library/Symbols";
import MessageHandler from "../Protocol/MessageHandler";
import ResponseReceiver from "../Response/Receiver";
import ResponseTransmitter from "../Response/Transmitter";

//
import MessageCoderWorker from "../MessageCoder/MessageCoderWorker";
import MessageCoderAtomic from "../MessageCoder/MessageCoderAtomic";
import BaseHandler, {WrapHandle} from "./BaseHandler";
import { wrapFunc } from "../Reflection/DirectReflection";
import SyncPromise from "../Library/SyncPromise"

//
import STD from "../Library/Standard";

//
export default class WorkerHandler extends BaseHandler {
    $worker = null;

    /**
     * Make object are access into object or class
     * @param {Worker} $worker WebWorker object
     * @param {Object} $options options of worker handler
     * @return {WorkerHandler} Worker handler and wrapper
     */
    constructor($worker, $options = {}) {
        super($worker, $options);

        //
        this.$outbox = [
            // synchronous
            new MessageCoderAtomic({
                $detector: this.$detector, 
                $dictionary: this.$dictionary, 
                $requestReflect: this.$requestReflect, 
                $indirectReflect: this.$indirectReflect, 
                $promiseReflect: this.$promiseReflect,
                $encode: $options.encode,
                $decode: $options.decode,
                $handler: this
            }),

            // asynchronous
            new MessageCoderWorker({
                $detector: this.$detector, 
                $dictionary: this.$dictionary, 
                $requestReflect: this.$requestReflect, 
                $indirectReflect: this.$indirectReflect, 
                $promiseReflect: this.$promiseReflect,
                $encode: $options.encode,
                $decode: $options.decode,
                $handler: this
            }),
        ];

        //
        this.$inbox = new MessageCoderWorker({
            $detector: this.$detector, 
            $dictionary: this.$dictionary, 
            $requestReflect: this.$requestReflect, 
            $indirectReflect: this.$indirectReflect, 
            $promiseReflect: this.$promiseReflect,
            $encode: $options.encode,
            $decode: $options.decode,
            $handler: this
        });

        //
        this.$messageHandler = new MessageHandler(this.$responseReceivers, this.$responseTransmitters, this.$outbox[1], this.$dictionary, this);
        this.$worker = $worker;

        //
        this.$inbox.$messageHandler = this.$messageHandler;
        this.$outbox[0].$messageHandler = this.$messageHandler;
        this.$outbox[1].$messageHandler = this.$messageHandler;

        //
        this.$dictionary._requestReflect = this.$requestReflect;
        this.$dictionary._indirectReflect = this.$indirectReflect;

        //
        this.$worker?.addEventListener?.("message", async (e) => {
            const $rw = await this.$inbox.decodeMessage(...this.$unchan(e.data, e));
            const $dc = $rw[0];
            if ($dc[0].$type == "request") {
                this.$responseTransmitters.set($dc[0].$id, new ResponseTransmitter($dc[0].$id, this));
            };
            this.$messageHandler.handleRequest(...$rw);
        });
    }

    //
    get ["&code"]() {
        return {
            "&typeof": "socket"
        }
    }

    //
    $feedback($param, $code) {

        // send back identifier
        this.$outbox.encodeMessage([{ ...$param, $type: "message", $args: [$code] }], []).then((_args_) => {
            this.$worker?.emit?.("message", _args_[0][0]);
        }).catch(console.error.bind(console));

    }

    //
    $request({$type = "request", $worker = null, $async = false, $cmd, $args, $persistent}) {
        const $coder = ({
            "message": this.$outbox[1], 
            "request": this.$outbox[$async ? 1 : 0], 
            "response": this.$inbox,
        }[$type]);

        //
        const $buffer = new (typeof SharedArrayBuffer != "undefined" ?  SharedArrayBuffer : ArrayBuffer)(4096+8, { maxByteLength: 65536+8 });
        const $tf = [], $id = this.$newUUID(), $rec = new ResponseReceiver($id, $buffer);
        this.$responseReceivers.set($id, $rec);

        //
        const $request = (_args_) => {
            // workaround transfer encoded message
            if (_args_.length == 1)  _args_.push([]); 
            if (!_args_[1]) _args_[1] = [];

            //
            this.$worker?.postMessage?.(this.$chan(_args_), _args_[1].filter(this.$detector.$dropShared.bind(this.$detector)));
        };

        //
        const $code = $coder.encodeMessage([{ $id, $type, $worker, $persistent, $cmd, $args }, $buffer, false], $tf);
        if ($code instanceof Promise) 
            $code.then($request); 
        else 
            $code |> $request;

        //
        return new Proxy(wrapFunc({
            ["&data"]: ($async ? $rec["&data"] : new SyncPromise($rec["&data"], $buffer, this.$outbox[0])),
            ["&code"]: {
                ["&typeof"]: "promise"
            }
        }), this.$promiseReflect);
    }

    //
    $reject(...$args) {
        this.$worker?.postMessage?.($args, $args[1].filter(this.$detector.$dropShared.bind(this.$detector)));
    }

    //
    $resolve(...$args) {
        this.$worker?.postMessage?.($args, $args[1].filter(this.$detector.$dropShared.bind(this.$detector)));
    }
};

// ES6-modules alike (in v2.3 planned to complete quest)
export const WrapWorker = ($W, $options) => {
    return new Proxy(new WorkerHandler($W, $options), new WrapHandle(true));
}

//
STD.WrapWorker = WrapWorker;
