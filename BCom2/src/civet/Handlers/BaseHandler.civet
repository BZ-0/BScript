// @ts-nocheck
"use strict";

//
import AutoDetector from "../Reflection/AutoDetector";
import RequestReflection from "../Reflection/RequestReflection";
import PromiseReflection from "../Reflection/PromiseReflection";
import ReferenceDictionary from "../Protocol/ReferenceDictionary";
import { IndirectReflection } from "../Reflection/DirectReflection";
import { $unwrap } from "../Reflection/PromiseReflection";
import { isWorker, $symbols, $contextify, uuidv4 } from "../Library/Symbols";

/**
 *
 * @export
 * @class BaseHandler
 */
export default class BaseHandler {
    /** @type {MessageHandler} */
    $messageHandler = null;

    /** @type {Map<String, ResponseTransmitter>} */
    $responseTransmitters = new Map();

    /** @type {Map<String, ResponseReceiver>} */
    $responseReceivers = new Map();

    /** @type {Array<MessageCoderAsync|MessageCoderAtomic|MessageCoderNetwork|MessageCoderWorker>} */
    $inbox = null;

    /** @type {Array<MessageCoderAsync|MessageCoderAtomic|MessageCoderNetwork|MessageCoderWorker>} */
    $outbox = null;

    /** */
    $reflect = Reflect;

    /** @type {RequestReflection} */
    $requestReflect = Reflect;

    /** @type {IndirectReflection} */
    $indirectReflect = Reflect;

    /** @type {PromiseReflection} */
    $promiseReflect = Reflect;

    /** */
    $dictionary = null;

    /** */
    $detector = null;

    //
    constructor(_, $options = {}) {
        $options = {
            prefix: "",
            base: new Map(),
            ...($options||{})
        };

        //
        this.$detector = new AutoDetector({});
        this.$dictionary = new ReferenceDictionary();

        /** @type {Reflect} */
        this.$reflect = Reflect;

        /** @type {RequestReflection} */
        this.$requestReflect = new RequestReflection(this);

        /** @type {IndirectReflection} */
        this.$indirectReflect = new IndirectReflection(this.$reflect, this.$dictionary);

        /** @type {PromiseReflection} */
        this.$promiseReflect = new PromiseReflection();
    }

    //
    $unchan($msg, $e) {
        return [$msg[0], $msg[1].map((e)=>{
            if (e["&typeof"] == "port") return $e.ports[e["&port"]];
            return e;
        }), ...$msg.slice(2)];
    }

    //
    $chan($msg) {
        let portIdx = 0;
        return [$msg[0], $msg[1].map((e)=>{
            if (e instanceof MessagePort) return {"&port": portIdx++, "&typeof": "port"};
            return e;
        }), ...$msg.slice(2)];
    }

    //
    $newUUID() { return (crypto?.randomUUID?.() ?? uuidv4()); }

    //
    $transfer($cid, $transferable, $shared) {
        const indices = $transferable.map((_,i) => $shared.length+i);
        $shared.push(...$transferable);
        const $promise = this.$messageHandler.$promise($cid);
        return {
            "&data": $promise["&data"],
            "&code": {
                ...$promise["&code"],
                "&index": indices[0]
            }
        };
    }

    /** */
    $request({}) { return null; }

    /**
     * Make object are accessible from host or remote
     * @param  {Object | Function} $obj object or class to share access
     * @param  {String} $proxy access object or name
     * @return {Proxy<Object | Function>} access code with proxy into class
     */
    register($obj, $proxy = null) { return this.$dictionary.$register($obj, $proxy); };

    /**
     * Make are access into object or class
     * @param  {String} $proxy access object or name
     * @return {Proxy<Object | Function>} access code with proxy into class
     */
    access($proxy, {
        $persistent = true,
        $async = false,
        $identify = true
    } = {}) { return this.$request({$cmd: "access", $identify, $async, $persistent, $args: [$proxy?.["&proxy"] || $proxy]}); };

}

/**
 * 
 */
export class WrapHandle {
    #enablePromise = false;

    constructor(enablePromise = false) {
        this.#enablePromise = enablePromise;
    }

    //
    get($handle, $name) {
        if ($name == "&isCode")
            return false;
        if ($name == "&isWrap")
            return true;
        if ($name == "&code") 
            return ($handle?.["&code"] ?? {});
        if ($name == "&data") 
            return new Proxy($handle, this);
        if ($name.at(0) == "&") 
            return ($handle?.["&code"] ?? {})?.[$name];

        //
        if (["catch", "then", "finally"].indexOf($name) >= 0) {
            const $ak = $unwrap($handle.access("$keys", {$identify: isWorker, $persistent: true})).then(($keys) => {
                const $m = Object.fromEntries($keys.map(($k) => {
                    return [$k, $handle.access($k, {$persistent: true, $identify: isWorker})];
                }));
                $m["socket"] = $handle["socket"];
                $m["worker"] = $handle["worker"];
                return $m;
            });
            return $contextify($ak, $ak?.[$name]);
        }

        //
        if (["socket", "worker"].indexOf($name) >= 0) 
            return $handle[$name];
        
        //
        if (["catch", "then", "finally", "constructor", "prototype", "toString", "valueOf"].indexOf($name) >= 0) 
            return null;

        //
        if ($name.at(0) == "&" || Object.values($symbols).indexOf($name) >= 0) 
            return null;

        //
        try { $name += ""; } catch (_) { return null; };
        return $handle.access($name);
    }

    set($handle, $name, $value) {
        return $handle.register($value, $name);
    }

    ownKeys($handle) {
        return $unwrap($handle.access("$keys"))
    }

    has($handle, $name) {
        return $unwrap($handle.access("$keys")).then(($k) => { return $k.indexOf($name) >= 0 });
    }
}
