// @ts-nocheck
"use strict";

//
import { _LOG_ } from "../Library/Symbols";
import MessageHandler from "../Protocol/MessageHandler";
import ResponseReceiver from "../Response/Receiver";
import ResponseTransmitter from "../Response/Transmitter";

//
import STD from "../Library/Standard";
import MessageCoderNetwork from "../MessageCoder/MessageCoderNetwork";
import BaseHandler, {WrapHandle} from "./BaseHandler";
import { wrapFunc } from "../Reflection/DirectReflection";

/**
 * 
 */
export default class SocketHandler extends BaseHandler {
    $socket = null;

    /**
     * Make object are access into object or class
     * @param {Worker} $socket WebWorker object
     * @param {Object} $options options of worker handler
     * @return {WorkerHandler} Worker handler and wrapper
     */
    constructor($socket, $options = {}) {
        super($socket, $options);

        //
        this.$outbox = new MessageCoderNetwork({
            $detector: this.$detector, 
            $dictionary: this.$dictionary, 
            $requestReflect: this.$requestReflect, 
            $indirectReflect: this.$indirectReflect, 
            $promiseReflect: this.$promiseReflect,
            $encode: $options.encode,
            $decode: $options.decode,
            $handler: this
        })

        //
        this.$inbox = new MessageCoderNetwork({
            $detector: this.$detector, 
            $dictionary: this.$dictionary, 
            $requestReflect: this.$requestReflect, 
            $indirectReflect: this.$indirectReflect, 
            $promiseReflect: this.$promiseReflect,
            $encode: $options.encode,
            $decode: $options.decode,
            $handler: this
        });

        //
        this.$messageHandler = new MessageHandler(this.$responseReceivers, this.$responseTransmitters, this.$outbox, this.$dictionary, this);
        this.$socket = $socket;

        //
        this.$inbox.$messageHandler = this.$messageHandler;
        this.$outbox.$messageHandler = this.$messageHandler;

        //
        this.$dictionary._requestReflect = this.$requestReflect;
        this.$dictionary._indirectReflect = this.$indirectReflect;

        //
        this.$socket?.on?.("message", async (e) => {
            //console.log(e.data);
            const $rw = await this.$inbox.decodeMessage([e], []);
            const $dc = $rw[0];
            //console.log(dc);
            if ($dc[0].$type == "request") {
                this.$responseTransmitters.set($dc[0].$id, new ResponseTransmitter($dc[0].$id, this));
            };
            this.$messageHandler.handleRequest(...$rw);
        });
    }

    //
    get ["&code"]() {
        return {
            "&typeof": "socket"
        }
    }

    //
    get socket() {
        return this.$socket;
    }

    //
    $request({$type = "request",  $socket = null, $cmd, $args, $persistent}) {
        const $coder = ({
            "message": this.$outbox, 
            "request": this.$outbox, 
            "response": this.$inbox,
        }[$type]);

        //
        const $buffer = new (typeof SharedArrayBuffer != "undefined" ?  SharedArrayBuffer : ArrayBuffer)(4096+8, { maxByteLength: 65536+8 });
        const $tf = [], $id = this.$newUUID(), $rec = new ResponseReceiver($id, $buffer);

        //
        this.$responseReceivers.set($id, $rec);
        $coder.encodeMessage([{ $id, $type, $socket, $persistent, $cmd, $args }, $buffer, false], $tf).then((_args_) => {
            this.$socket?.emit?.("message", _args_[0][0]);
        }).catch(console.error.bind(console));

        //
        return new Proxy(wrapFunc({
            ["&buffer"]: $buffer,
            ["&data"]: $rec["&data"],
            ["&code"]: {
                ["&typeof"]: "promise"
            }
        }), this.$promiseReflect);
    }

    // 
    $reject(...$args) {
        //console.error(...$args);
        this.$socket?.emit?.("message", $args[0][0]);
    }

    // 
    $resolve(...$args) {
        this.$socket?.emit?.("message", $args[0][0]);
    }
};

// ES6-modules alike (in v2.3 planned to complete quest)
export const WrapSocket = ($W, $options) => {
    return new Proxy(new SocketHandler($W, $options), new WrapHandle(true));
}

// learn sockets for STD
STD.WrapSocket = WrapSocket;
