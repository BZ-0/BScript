// @ts-nocheck
"use strict";

//
import { uuidv4 } from "../Library/Symbols";
import { wrapFunc } from "../Reflection/DirectReflection";
import { ReadbackReflection } from "../Reflection/DirectReflection";

//
export default class DataChannel {
    /** @type {WorkerHandler|SocketHandler|BaseHandler} */
    #handle = null;

    /** @type {String} */
    #cid = "";

    /** @type {ReferenceDictionary} */
    #dictionary = null;

    /** @type {Map<String, Object>} */
    #promised = new Map();

    /** @type {MessageHandler} */
    #message = null;

    /**
     * 
     * @param {String} cid 
     * @param {ReferenceDictionary} dictionary 
     * @param {WorkerHandler|SocketHandler|BaseHandler} handle 
     * @param {MessageHandler} message 
     */
    constructor(cid, dictionary, handle, message) {
        this.#cid = cid;
        this.#dictionary = dictionary;
        this.#promised = new Map();
        this.#handle = handle;
        this.#message = message;
    }

    //
    #newUUID() { return (crypto?.randomUUID?.() ?? uuidv4()); }

    //
    $finalizer($holder) {
        this.#message.$finalizer($holder, this.#cid);
        return this;
    }

    //
    $promise() {
        const $p = { $resolve: null, $reject: null };
        Object.assign($p, {
            ["&data"]: new Promise(($resolve, $reject) => {
                $p.$resolve = $resolve;
                $p.$reject = $reject;
            }),
            ["&code"]: {
                "&isCode": true,
                "&local": this.#newUUID() 
            }
        });
        this.#promised.set($p["&code"]["&local"], $p);
        return $p;
    }

    // send identifier report to promised
    $feedback($meta, $transfered) {
        return this.#handle.$feedback({
            "&cmd": "feedback", 
            "&cid": this.#cid
        }, {
            ...$meta,
            ...this.#dictionary.$temp($transfered)?.["&code"]
        });
    }

    // when encoding...
    $transfer($transferable = [], $shared = []) {
        const $obj = this.#handle.$transfer(this.#cid, $transferable, $shared);
        return new Proxy(wrapFunc({
            ...$obj
        }), new ReadbackReflection(this.#handle));
    }

    //
    handleMessage({$cmd}, {"&local": $local, "&origin": $origin}) {
        switch ($cmd) {
            case "feedback": {
                const $promised = this.#promised.get($local);
                this.#promised.delete($local);
                $promised.$resolve({"&origin": $origin});
            } //break;
            default:
        }
    }
};
