// @ts-nocheck
"use strict";

//
import { _LOG_ } from "../Library/Symbols";
import DataChannel from "./DataChannel";
import PathReflect from "../Reflection/PathReflect";

// 
export default class MessageHandler {

    /** @type {Map<String, ResponseReceiver>} */
    #responseReceivers = {};

    /** @type {Map<String, ResponseTransmitter>} */
    #responseTransmitters = {};

    /** @type {MessageCoderAsync|MessageCoderAtomic|MessageCoderNetwork|MessageCoderWorker} */
    #outboxCoder = null;

    /** @type {PathReflect} */
    #reflect = PathReflect;

    /** @type {ReferenceDictionary} */
    #dictionary = null;

    /** @type {Map<String, DataChannel>} */
    #channels = new Map();

    /** @type {BaseHandler|WorkerHandler|SocketHandler} */
    #handle = null;

    /** @type {FinalizationRegistry} */
    #finalization = null;

    /** @type {WeakMap} */
    #cib = null;

    /**
     * 
     * @param {Map<String, ResponseReceiver>} responseReceivers 
     * @param {Map<String, ResponseTransmitter>} responseTransmitters 
     * @param {MessageCoderAsync|MessageCoderAtomic|MessageCoderNetwork|MessageCoderWorker} outboxCoder 
     * @param {ReferenceDictionary} dictionary 
     * @param {BaseHandler|WorkerHandler|SocketHandler} handle 
     */
    constructor(responseReceivers, responseTransmitters, outboxCoder, dictionary, handle) {
        this.#responseTransmitters = responseTransmitters;
        this.#responseReceivers = responseReceivers;
        this.#outboxCoder = outboxCoder;
        this.#dictionary = dictionary;
        this.#reflect = PathReflect;//PathReflect;//(typeof Reflect != "undefined" ? Reflect : FakeReflect);
        this.#channels = new Map();
        this.#handle = handle;
        this.#finalization = new FinalizationRegistry(($cid) => {
            this.#channels.delete($cid);
        });
        this.#cib = new WeakMap();
    }

    //
    $initiate({"&cid": $cid = null}) {
        if ($cid && !this.#channels.has($cid)) {
            const $new = new DataChannel($cid, this.#dictionary, this.#handle, this);
            this.#channels.set($cid, $new);
            return $new;
        }
        return this.#channels.get($cid);
    }

    //
    $finalizer($holder, $cid) {
        if (!this.#cib.has($holder)) {
            this.#cib.set($holder, $cid);
            this.#finalization.register($holder, $cid);
        }
        return this;
    }

    //
    $promise($cid) {
        return this.#channels.get($cid).$promise();
    }

    //
    async handleRequest([{
        $id = "", 
        $cmd = "", 
        $worker = null, 
        $args = [], 
        $persistent = true, 
        $cid = null, 
        $type = "unknown"
    }, $buffer = null]) {
        {
            switch ($type) {
                // got message
                case "message": if ($cid) {
                    const $channel = this.#channels.get($cid);
                    $channel?.handleMessage?.({$cmd}, {...$args[0]});
                }
                //break;

                //
                case "request": {
                    //
                    const responseTransmitter = this.#responseTransmitters.shift($id);
                    if (responseTransmitter) {
                        const $tf = [];
                        const $proxy = await $args.shift();
                        let $obj = null, $got = null;

                        try {
                            $obj = (this.#dictionary.$get($proxy, $persistent) ?? $proxy);
                            $got = ($cmd == "access" ? $obj : this.#reflect[$cmd]($obj, ...(await Promise.all($args))));

                            //
                            responseTransmitter.resolve(...(await this.#outboxCoder.encodeMessage([{
                                $id, 
                                $cmd, 
                                $type: "result", 
                                $worker,
                                $args: [$got],
                            }, $buffer, true], $tf)));
                        } catch(e) {
                            console.error(e);
                            responseTransmitter.reject(...(await this.#outboxCoder.encodeError([{
                                $id, 
                                $cmd, 
                                $type: "error",
                                $worker,
                                $args: [`Error Message: ${e?.message};\nFile Name: ${e?.fileName};\nLine Number: ${e?.lineNumber}`],
                                $message: e?.message,
                                $fileName: e?.fileName,
                                $lineNumber: e?.lineNumber
                            }, $buffer, true], $tf)));
                        };
                    }
                    
                }
                //break;

                case "result": {
                    const responseReceiver = this.#responseReceivers.shift($id);
                    if (responseReceiver) {
                        // needs to add "&buffer" into receiver?!
                        responseReceiver.resolve(...await $args);
                    }
                }
                //break;

                case "error": {
                    const responseReceiver = this.#responseReceivers.shift($id);
                    if (responseReceiver) {
                        responseReceiver.reject(...await $args);
                    }
                }
                //break;

                default:
            }
        }
        return 
    }
};
